Der _CSA_ berechnet die Summe der unteren $n/2$ bits und gleichzeitig die Summe der oberen $n/2$ bits, einaml für das Carry $c_{(n/2)}=1$ und und einmal für $=0$ (mittels [[Carry Ripple Addierer]]) und entscheidet dann mit einem [[Multiplexer]] welchen der oberen mögichen ergebnisse er basierend auf der _Condition_ des Carry-Bits der unteren Addition durchschaltet

![[Pasted image 20250210170916.png]]
